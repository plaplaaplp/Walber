# -*- coding: utf-8 -*-
"""Metodonumerico##.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1-_b0G3Oc4pftQCRq47xtCiEyqofANs7c
"""

# METODO BISSEÇÃO
import numpy as np
import matplotlib.pyplot as plt
x = np.linspace(-np.pi,np.pi,10000)

cosx = x - np.cos(x)


fig = plt.figure(figsize=(15,15)) 

fig, ax = plt.subplots()

ax.plot(x, cosx, color="black", label ="x - cos(x)") 

ax.legend()
plt.grid()
plt.show()

f = cosx
e = 1e-6
i = 0
j = len(f) - 1

N = 1000
n = 0
while np.abs(f[i]-f[j])>=e:

  # 
  n+=1
  #print(f'Iteração número: {n}')
  if n > N:
    break
  
  k = int(np.floor(i+j)*(1/2))
  
  if (f[i]*f[k])<0:
    j = k
  else:
    i=k
print("Zero da Função em x=", x[k])

# METODO BISSEÇÃO
import numpy as np
import matplotlib.pyplot as plt
x = np.linspace((-1)*np.pi,0,1000000)

exp = 2*np.cos(x) + np.exp(x)*(1/2)

fig = plt.figure(figsize=(15,15)) 

fig, ax = plt.subplots()

ax.plot(x, exp, color="black", label ="f(x)") 

ax.legend()
plt.grid()
plt.show()

f = exp

e = 1e-6
i = 0
j = len(f) - 1

N = 1000
n = 0
while np.abs(f[i]-f[j])>=e:

  # 
  n+=1
  #print(f'Iteração número: {n}')
  if n > N:
    break
  
  k = int(np.floor(i+j)*(1/2))
  
  if (f[i]*f[k])<0:
    j = k
  else:
    i=k
print("Zero da Função em x=", x[k])

#METODO MIL
import numpy as np
import matplotlib.pyplot as plt
x = np.linspace(-3,3,100)

fx = (x**3) - 9*x + 3
phix = (x**3)/9 + 1/3

fig = plt.figure(figsize=(15,15)) 

fig, ax = plt.subplots()

ax.plot(x, fx, color="red", label ="f(x)")

ax.plot(x, phix, color="black", label ="phi(x)")


ax.legend()
plt.grid()
plt.show()

def f(x): return (x**3)/9 + 1/3
#def g1(x): return x-0.5*f(x)  
x=0.5
n=0
N= 10000
#x=f(x);x 
e = 1e-5
xa = -x
while np.abs(x-xa)>= e :
  xa = x
  x = f(x);x 
  n+=1
  #print(f'Iteração número: {n}')
  if n > N:
    break
  print("zero da função", x)

# METODO NEWTON-RAPHSON
import math
import numpy as np
import matplotlib.pyplot as plt

x = np.linspace(-1,3,100)
fx1 = x*np.log10(x)-1
fx2= np.tan(1.5*x)-x
fig = plt.figure(figsize=(15,15)) 
fig, ax = plt.subplots()
ax.plot(x, fx1, color="black", label ="f(x)xlog(x)-1") 
ax.legend()
fig2 = plt.figure(figsize=(15,15))
fig2, ax2 = plt.subplots()
ax2.plot(x, fx2, color="red", label ="f(x)=tan(1.5x) - x")
ax.legend()


class ddx:
    def __init__(self, f, h=1e-6):
        self.f = f
        self.h = float(h)

    def __call__(self, x):
        f = self.f
        h = self.h
        return (f(x+h) - f(x))/h




def g(t): return (t*math.log10(t)-1)
ddg = ddx(g)
t = 5
def gn(t): return t - (g(t)/ddg(t))
x1 = gn(t)
x2 = gn(x1)
x3 = gn(x2)
x4 = gn(x3)
x5 = gn(x4)
print("Metodo Newton-Raphson 5 iterações: f(x)xlog(x)-1 = ", x5)

def g(t): return (math.tan(1.5*t)-t)
ddg = ddx(g)
t = 1
def gn(t): return t - (g(t)/ddg(t))
x11 = gn(t)
x22 = gn(x11)
x33 = gn(x22)
x44 = gn(x33)
x55 = gn(x44)
x66 = gn(x55)
x77 = gn(x66)
x88 = gn(x77)
x99 = gn(x88)
x999 = gn(x99)

print("Metodo Newton-Raphson 7 iterações f(x)=tan(1.5x) - x=", x99)

# METODO NEWTON-RAPHSON COM WHILE
import math
import numpy as np
import matplotlib.pyplot as plt



class ddx:
    def __init__(self, f, h=1e-6):
        self.f = f
        self.h = float(h)

    def __call__(self, x):
        f = self.f
        h = self.h
        return (f(x+h) - f(x))/h

def g(t): return (t*math.log10(t)-1)
ddg = ddx(g)
t = 5
def gn(t): return t - (g(t)/ddg(t))
xa = -t
e = 1e-6
N = 100
while np.abs(t-xa)>= e :
  xa = t
  t = gn(t);t 
  n+=1
  print("zero da função xlog(x) - 1 = ", t)
  #print(f'Iteração número: {n}')
  if n > N:
    break

# METODO NEWTON-RAPHSON COM WHILE E DERIVADA FUNCIONAL

import math
import numpy as np
import matplotlib.pyplot as plt



def g(t): return (math.tan(1.5*t)-t)
def dde(t):
  h=1e-6
  return (g(t+h) - g(t))/h

t = 1
def gn(t): return t - (g(t)/dde(t))
e = 1e-6
xa = -t
n = 0
N = 100
while np.abs(t- xa)>= e:
  xa = -t
  t = gn(t)
  print("zero da função tan(1.5x)-x = ", t)
  n+=1
  if n > N:
    break

# DERIVADA USANDO SÓ UMA FUNÇÃO DEF 
import math
import numpy as np
import matplotlib.pyplot as plt

t = 5
def g(t): return (t*math.log10(t)-1)
def dde(t):
  h=1e-6
  return (g(t+h) - g(t))/h
dx = dde(t)

#METODO DAS SECANTES
import math
import numpy as np
import matplotlib.pyplot as plt

t0 = 10
t1 = 7

def g(t): return (t*math.log10(t)-1)

def gs(t1, t0): 
  return t1 - (g(t1)*(t0-t1))/(g(t0) - g(t1))

e = 1e-6
n = 0
N = 100

xa = t1
xb = t0

while np.abs(xa-xb)>= e:
  t1 = xa
  t0 = xb
  tn = gs(t1, t0)
  print("zero da f = ", tn)
  xa = tn
  xb = t1
  print("t0 =", t0,"t1 =", t1)
  n+=1
  if n > N:
    break
print("zero da f = ", tn)

#METODO DAS SECANTES
import math
import numpy as np
import matplotlib.pyplot as plt

t0 = 0.5
t1 = 0.25

def g(t): return (-np.log(t))

def gs(t1, t0): 
  return t1 - (g(t1)*(t0-t1))/(g(t0) - g(t1))

e = 1e-6
n = 0
N = 100

xa = t1
xb = t0

while np.abs(xa-xb)>= e:
  t1 = xa
  t0 = xb
  tn = gs(t1, t0)
  xa = tn
  xb = t1
  print("t0 =", t0,"t1 =", t1)
  n+=1
  if n > N:
    break
print("zero da ln(x)= ", tn)